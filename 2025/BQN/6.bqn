#!/usr/bin/env bqn
âŸ¨Ints, InputâŸ© â† â€¢Import "../../utils/utils.bqn"
aâ€¿b â† Â¯1(â†“â‹ˆâŠ‘) â€¢FLines 2025â€¿6 Input â€¢args

o â† Ã—â€¿+âŠËœ '+'= ' 'âŠ¸â‰ âŠ¸/ b # extract the operations from the last line, convert to BQN objects

S â† {+Â´ o{ğ•Â´ğ•©}Â¨ ğ•©} # all the folds
â€¢Show S <Ë˜ â‰ âŸ¨â‰ a,âˆ˜âŸ©â¥Š âˆ¾IntsÂ¨ a # for part 1, can just boringly extract all numbers in each row

# part 2:
nums â† 0 { row ğ•Š acc: # fold over rows:
  sp â† row=' '
  (spÃ—acc) + (Â¬sp)Ã— (10Ã—acc) + row-'0' # add digit row if not space
  # acc âŠ£âŒ¾(spâŠ¸/) (10Ã—acc) + row-'0' # TODO this + (0Â¨âŠ‘a) accumulator start when it's fast (and/or Case)
}Â´ âŒ½a

â€¢Show S numsâŠ”Ëœ (âŠ¢-ËœÂ¬Ã—+`) 0=nums # group by zeroes (0 is produced for all-spaces columns, and isn't present otherwise)

### alternative part 2:
# ta â† â‰>a # for part 2, work on transposed values
# g â† (Â¬/+`) âˆ§ËË˜' '=ta # find all-spaces rows (i.e. columns in input pre-tranpose), and create a group mask for each non-empty row
# â€¢Show S g âŠ” Ints â¥Š' 'âˆ¾Ë˜ta # parse all transposed numbers (making sure to not let numbers from adjacent columns merge)
