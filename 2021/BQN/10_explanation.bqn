# start:
57â€¿3â€¿25137â€¿1197â€¿0âŠ‘Ëœ 2Ã·ËœÂ¯1+ (iâˆ¾9)âŠ‘Ëœ âŒŠÂ´(âŠ”d) {(1+2Ã— 0âŠ‘âˆ˜âŠËœ =Â´Ë˜âˆ˜â€¿2â¥Š ğ•©âˆ¾9â¥ŠËœ2|â‰ ğ•©) âŠ‘ ğ•¨âˆ¾oob}Â¨ dâŠ”âŒŠiÃ·2
                                     (âŠ”d)                                                  # position per depth: each item is a list of positions of characters at the given depth
                                                                                    dâŠ”âŒŠiÃ·2 # bracket type per depth: each item is a list of bracket types at the current depth
                                     (âŠ”d) {(1+2Ã— 0âŠ‘âˆ˜âŠËœ =Â´Ë˜âˆ˜â€¿2â¥Š ğ•©âˆ¾9â¥ŠËœ2|â‰ ğ•©) âŠ‘ ğ•¨âˆ¾oob}Â¨ dâŠ”âŒŠiÃ·2 # execute the block with ğ•¨ as the positions, and ğ•© as the types, per depth
  # example:
  # str:   <()([])[}<
  # index: 0123456789
  # depth: 0111221111
  # i:     4232013074
  # type:  2111001032
  
  # consider depth 1:
  #         ()(  )[}<
  #   ğ•¨:    123  6789 â†’ 1â€¿2â€¿3â€¿6â€¿7â€¿8â€¿9 (subset of the "index" above)
  #   ğ•©:    111  1032 â†’ 1â€¿1â€¿1â€¿1â€¿0â€¿3â€¿2 (subset of "type" above)
  # string: ()()[}< - for reference; we don't use it anywhere; the nature of depth guarantees that even indices are opening brackets and odd ones are closing ones
# inner dfn:
  {(1+2Ã— 0âŠ‘âˆ˜âŠËœ =Â´Ë˜âˆ˜â€¿2â¥Š ğ•©âˆ¾9â¥ŠËœ2|â‰ ğ•©) âŠ‘ ğ•¨âˆ¾oob} # whole thing for reference
                       ğ•©âˆ¾9â¥ŠËœ2|â‰ ğ•©           # append a 9 to ğ•© if the length is odd: 1â€¿1â€¿1â€¿1â€¿0â€¿3â€¿2â€¿9
                  âˆ˜â€¿2â¥Š                     # reshape into two columns: >âŸ¨1â€¿1,1â€¿1,0â€¿3,2â€¿9âŸ©
               =Â´Ë˜                         # check if columns are equal: 1â€¿1â€¿0â€¿0
         0âŠ‘âˆ˜âŠËœ                             # find index of first mismatch: 2; This gives us the first mismatched character at the current depth
                                           # in the string "()()[}<", that's pointing at the 3rd bracket pair
     1+2Ã—                                  # to convert to the actual index of "}", we need to double the index, and add one to point at the erroring closing brace and not the opening one
   ( 1+2Ã—                       ) âŠ‘ ğ•¨âˆ¾oob  # pick that'th element of the indexes
                                           # or return OOB if there were no mismatches and thus âŠ returned one-past-last
# post-processing:
                                âŒŠÂ´  # smallest erroring index from all of the ones we've seen
                         (iâˆ¾9)âŠ‘Ëœ    # pick that from the indexes, returning the bracket character index
                   2Ã·ËœÂ¯1+           # convert the bracket character index to a type index
57â€¿3â€¿25137â€¿1197â€¿0âŠ‘Ëœ                 # and get that-th element of the lookup table