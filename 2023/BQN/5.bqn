#!/usr/bin/env bqn
âŸ¨Ints, SplitF, InputâŸ© â† â€¢Import "../../utils/utils.bqn"
l â† âŸ¨âŸ©SplitF â€¢FLines 2023â€¿5 Input â€¢args
s â† Ints âŠ‘âŠ‘l
l â†© {<Ë˜â‰>IntsÂ¨ 1â†“ğ•©}Â¨ 1â†“l

â€¢Show âŒŠÂ´s { ğ•¨ ğ•Š dâ€¿sâ€¿l:
  ğ•¨ + +ËË˜ (d-s) Ã—â‰1 (ğ•¨ â‰¥âŒœ s) âˆ§ ğ•¨ <âŒœ s+l
}ËœÂ´âŒ½ l

# current range set represented by âŸ¨list of starts â‹„ list of ends (exclusive)âŸ©
â€¢Show âŒŠÂ´âŠ‘ (<Ë˜ +` â‰ âˆ˜â€¿2â¥Šs) { vsâ€¿ve ğ•Š dâ€¿sâ€¿l:
  # vs,ve: start/end of previous sets
  # d,s,l: current mappings, serparated into columns
  ds â† d-s # delta a given mapping applies when matched
  
  ak â† â·âˆ§vsâˆ¾veâˆ¾sâˆ¾s+l # all key points at which values may change
  
  us â† akâ‹s-1   # offset in key where a mapping starts
  ue â† akâ‹s+l-1 # .. and where it ends
  tr â† +` -âŸœdsâŒ¾(ueâŠ¸âŠ) dsâŒ¾(usâŠ¸âŠ) 0Â¨ ak # delta to apply at each key point; don't need some +Â´Â¨wâŠ”ds thing as, even though intervals can start where another ended, one will never start where another started or end where another ended
  
  rs â† akâ‹vs-1 # offset in key where a previous-range starts
  re â† akâ‹ve-1 # .. and where it ends
  
  mm â† +` rs -â—‹((â‰ ak)â†‘/â¼) re # which key-point intervals are in the previous set; last element is always 0
  akns â† tr +  ak # all key point next interval start
  akne â† tr + Â«ak # ..and end
  âŸ¨mm/akns, mm/akneâŸ© # filter the intervals. Don't bother merging adjacent ones
  
  # alternative less array-y way of computing the result:
  # (<âˆ˜â‹âŠ‘)âŠ¸(âŠÂ¨) <Ë˜â‰> âˆ¾ {crsâ€¿cre: (crsâ†“creâ†‘tr) + <Ë˜2â†•crsâ†“(cre+1)â†‘ak}Â¨ rs â‹ˆÂ¨ re
}ËœÂ´âŒ½ l