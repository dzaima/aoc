#!/usr/bin/env cbqn
âŸ¨Ints, SplitFâŸ© â† â€¢Import "utils.bqn"
l â† âŸ¨âŸ©SplitF â€¢FLines â‰ â—¶"5.in"â€¿âŠ‘ â€¢args
s â† Ints âŠ‘âŠ‘l
l â†© {IntsÂ¨ 1â†“ğ•©}Â¨ 1â†“l

â€¢Show âŒŠÂ´s {
  ğ•¨ + +ËË˜ğ•¨ { ğ•¨ğ•Šdâ€¿sâ€¿l:
    (d-s) Ã— (ğ•¨â‰¥s) âˆ§ ğ•¨<s+l
  }âŒœ ğ•©
}ËœÂ´âŒ½ l

# current range set represented by âŸ¨list of starts â‹„ list of ends (exclusive)âŸ©
â€¢Show âŒŠÂ´âŠ‘ (<Ë˜ +` â‰ âˆ˜â€¿2â¥Šs) {
  vsâ€¿ve â† ğ•¨ # previous sets
  [d,s,l] â† â‰>ğ•© # current mapping per-column
  ds â† d-s # delta from a given mapping when it matches
  
  ak â† â·âˆ§vsâˆ¾veâˆ¾sâˆ¾s+l # all key points at which values may change
  
  us â† akâ‹s-1   # offset in key where a mapping starts
  ue â† akâ‹s+l-1 # .. and where it ends
  tr â† +` -âŸœdsâŒ¾(ueâŠ¸âŠ) dsâŒ¾(usâŠ¸âŠ) 0Â¨ ak # delta to apply at each key point; don't need some +Â´Â¨wâŠ”ds thing as, even though intervals can start where another ended, one will never start where another started or end where another ended
  
  rs â† akâ‹vs-1 # offset in key where a previous-range starts
  re â† akâ‹ve-1 # .. and where it ends
  
  mm â† +` rs -â—‹((â‰ ak)â†‘/â¼) re # which key-point intervals are in the previous set; last element is always 0
  akns â† tr +  ak # all key point next interval start
  akne â† tr + Â«ak # ..and end
  âŸ¨mm/akns, mm/akneâŸ© # filter the intervals. Don't bother merging adjacent ones
  
  # alternative less array-y way of computing the result:
  # (<âˆ˜â‹âŠ‘)âŠ¸(âŠÂ¨) <Ë˜â‰> âˆ¾ {crsâ€¿cre: (crsâ†“creâ†‘tr) + <Ë˜2â†•crsâ†“(cre+1)â†‘ak}Â¨ rs â‹ˆÂ¨ re
}ËœÂ´âŒ½ l