#!/usr/bin/env bqn
âŸ¨InputâŸ© â† â€¢Import "../../utils/utils.bqn"
l â† â€¢FChars 2024â€¿3 Input â€¢args

ks â† (-â‰ l)â†‘"mul("â·l  # class 1: start mask (marks the opening paren)
km â† l=','           # class 2: middle separator mask
ke â† l=')'           # class 3: end mask
kn â† ('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') l # class 4: number mask
kncâ† knâˆ§Â»kn          # class 5: number continuation mask
class â† +Â´ âŸ¨ks, km, ke, kn, kncâŸ© Ã— 1â€¿2â€¿3â€¿4â€¿1 # class of each character
si â† 1+/ {class {(â‰ ğ•¨)â†‘1â€¿4â€¿2â€¿4â€¿3â·ğ•¨}âŒ¾(ğ•©âŠ¸/) 0Â¨class} 5â‰ class # find the mul(n,n) pattern under filtering out number continuation chars; returns indices of each first number
mi â† km /âŠ¸(â‹âŠâŠ£) si # location of corresponding comma for each of the above
ei â† ke /âŠ¸(â‹âŠâŠ£) si # location of corresponding end for each of the above
n0 â† â€¢ParseFloatÂ¨    si â†“Â¨ miâ†‘Â¨<l # parse the numbers between si and mi
n1 â† â€¢ParseFloatÂ¨ (1+mi)â†“Â¨ eiâ†‘Â¨<l # parse the numbers between 1+mi and ei
r â† n0Ã—n1 # the multiplications
â€¢Show +Â´ r

d1 â† / "do()"    â· l     # indices of dos
d0 â† / "don't()" â· l     # indices of don'ts
P â† {(ğ•¨â‹ğ•©) âŠ Â¯1âˆ¾ğ•¨}       # find the index of nearest smaller value in ğ•¨ for each in ğ•© via binary search (Â¯1 if not yet encountered)
do â† (d1 P mi) â‰¥ d0 P mi # whether a do is nearer than a don't (â‰¥ to make initial state true)
â€¢Show +Â´ do / r          # filter by that
