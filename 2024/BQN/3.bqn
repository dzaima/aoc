#!/usr/bin/env bqn
âŸ¨InputâŸ© â† â€¢Import "../../utils/utils.bqn"
l â† â€¢FChars 2024â€¿3 Input â€¢args

ks â† (-â‰ l)â†‘"mul("â·l  # class 1: start mask (marks the opening paren)
km â† l=','           # class 2: middle separator mask
ke â† l=')'           # class 3: end mask
kn â† ('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') l # class 4: number mask
kncâ† knâˆ§Â»kn          # class 5: number continuation mask
class â† +Â´ âŸ¨ks, km, ke, kn, kncâŸ© Ã— 1â€¿2â€¿3â€¿4â€¿1 # class of each character
si â† 1+/ {class {(â‰ ğ•¨)â†‘1â€¿4â€¿2â€¿4â€¿3â·ğ•¨}âŒ¾(ğ•©âŠ¸/) 0Â¨class} 5â‰ class # find the mul(n,n) pattern under filtering out number continuation chars; returns indices of each first number
mi â† km /âŠ¸(â‹âŠâŠ£) si # location of corresponding comma for each of the above
ei â† ke /âŠ¸(â‹âŠâŠ£) si # location of corresponding end for each of the above
n0 â† â€¢ParseFloatÂ¨    si â†“Â¨ miâ†‘Â¨<l # parse the numbers between si and mi
n1 â† â€¢ParseFloatÂ¨ (1+mi)â†“Â¨ eiâ†‘Â¨<l # parse the numbers between 1+mi and ei
r â† n0Ã—n1 # the multiplications
â€¢Show +Â´ r

d1 â† / "do()"    â· l # indices of dos
d0 â† / "don't()" â· l # indices of don'ts
da â† d1âˆ¾d0    # all relevant indices
dg â† â‹da      # grade: indices to sort da by
do â† dg < â‰ d1 # mask of dos
prev â† Â¯1 + (dgâŠda)â‹mi    # for each number, get nearest index in sorted da
â€¢Show +Â´(prev âŠ doâˆ¾1) / r # filter by whether that index is of a do(); the start gets index Â¯1, which wraps around to the end and hits the âˆ¾1